

0. There isn't consensus in the programming community about the features a language needs to have in order to be called object-oriented.

0. Even though structures and enums with methods aren't called objects, they provide the same functionality that objects do, using the Gang of Four's definition of objects.

0. I decided to give it a whirl and see what it takes to get a simple Hello World! running on the Raspberry Pi, which has been sitting in my desk draw for months now.

0. Last week we announced the availability of the first technology preview for Kotlin/Native, something that we’ve been working on since September 2016.

0. The zip file comes with a command line compiler, Gradle support and some samples.

0. Start tweeting your questions today and get answers during the Q&A session live stream on March 23.

0. Note to self: next time you write a workflow, provide a more meaningful message.

0. The more you travel, the more lonely airplanes, airports, lounges become.

0. Inheritance is a mechanism that some programming languages provide whereby an object can be defined to inherit from another object's definition, thus gaining the parent object's data and behavior without having to define those again.

0. There is not a way to define a struct that inherits from another struct in order to gain the parent struct's fields and method implementations.

0. One of Rust's influences is functional programming, where functions are values that can be used as arguments or return values to other functions, assigned to variables, and so forth.

0. Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines.

0. This is a simple program which generates C++ dynamic programming code from given state-translation equation, supporting varies forms of errors' handling.

0. If the project doesn't have any GitHub Releases you can use the short commit hash or 'anyBranch-SNAPSHOT' as the version.

0. The first difference is that we did not need to annotate the types of the parameters the closure takes or the value it returns.

0. The reason type annotations are not required for defining a closure but are required for defining a function is that functions are part of an explicit interface exposed to your users, so defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns.

0. Since closures' types can be inferred reliably since they're called directly, it would be tedious if we were required to annotate their types.

0. Creating closures that capture values from their environment is mostly used in the context of starting new threads.

0. The trait does not mandate anything about the behavior an iterator must have if the next method is called again after having returned one None value.

0. For example, if for some reason we wanted to take the first five values that an instance of Counter produces, pair those values with values produced by another Counter instance after skipping the first value that instance produces, multiply each pair together, keep only those results that are divisible by three, and add all the resulting values together, we could do so: ....

0. It's a bit tougher to understand at first, but once you gain an intuition for what the various iterator adaptors do, this is much easier to understand.

0. Instead of fiddling with the various bits of looping and building a new vector, the code focuses on the high-level objective of the loop, abstracting some of the commonplace code so that it's easier to see the concepts that are unique to this usage of the code, like the condition on which the code is filtering each element in the iterator.

0. We're not going to go through the benchmark code here, as the point is not to prove that they're exactly equivalent, but to get a general sense of how these two implementations compare.

0. For a real benchmark, you'd want to check various texts of various sizes, different words, words of different lengths, and all kinds of other variations.

0. In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for.

0. As mentioned at the start of the chapter, testing is a large discipline, and different people use different terminology and organization.

0. There's debate within the testing community about whether private functions should be tested directly or not, and other languages make it difficult or impossible to test private functions. 

0. The way command line programs are expected to work is that, because the output is an error message, it should be shown on the screen rather than being redirected to the file.

0. It's much more useful for error messages like this to be printed to standard error, and only have data printed to standard out from a successful run end up in the file when we redirect standard out in this way.

0. Rust makes a number of guarantees that we've talked about, for example that we'll never have a null value, and data races will be disallowed at compile time.
